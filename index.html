<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Baguette</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-dark: #0d0d12;
      --void-core: #7b2cbf;
      --void-mid: #9d4edd;
      --void-outer: #c77dff;
      --flame-core: #ff6b35;
      --flame-mid: #f7931e;
      --flame-outer: #ffd23f;
    }

    html, body {
      height: 100%;
      width: 100%;
      background: #2c2c3a;
      font-family: 'Press Start 2P', cursive;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
    }

    /* Gameboy Color shell */
    .container {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      padding: 1rem;
    }

    .gameboy-shell {
      background: linear-gradient(145deg, #6b5b95 0%, #5a4a84 50%, #4a3a74 100%);
      padding: 1.5rem 1rem 2.5rem 1rem;
      border-radius: 20px 20px 60px 60px;
      box-shadow:
        inset 0 2px 4px rgba(255,255,255,0.2),
        inset 0 -2px 4px rgba(0,0,0,0.3),
        0 10px 40px rgba(0,0,0,0.5);
      position: relative;
    }

    .gameboy-label {
      position: absolute;
      top: 0.5rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.35rem;
      color: rgba(255,255,255,0.7);
      letter-spacing: 0.15em;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .gameboy-label span {
      background: linear-gradient(90deg, #ff6b6b, #ffd93d, #6bcb77, #4d96ff, #9d65c9);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: bold;
    }

    /* Screen bezel */
    .screen-bezel {
      background: #1a1a24;
      padding: 0.6rem;
      border-radius: 8px;
      box-shadow:
        inset 0 3px 8px rgba(0,0,0,0.8),
        0 2px 4px rgba(255,255,255,0.1);
    }

    /* Gameboy screen */
    .viewport {
      width: min(85vw, 85vh, 480px);
      height: min(85vw, 85vh, 480px);
      background: linear-gradient(180deg, #1a2a1a 0%, #0f1a0f 50%, #1a2a1a 100%);
      border-radius: 4px;
      position: relative;
      overflow: hidden;
      box-shadow:
        inset 0 0 30px rgba(0, 0, 0, 0.5),
        0 0 60px rgba(100, 200, 100, 0.1);
    }

    /* Screen pixel grid overlay */
    .viewport::before {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 25;
      background:
        linear-gradient(rgba(0,0,0,0) 50%, rgba(0,0,0,0.15) 50%);
      background-size: 100% 3px;
    }

    /* Power LED */
    .power-led {
      position: absolute;
      bottom: 1.2rem;
      left: 1.5rem;
      width: 8px;
      height: 8px;
      background: #4ade80;
      border-radius: 50%;
      box-shadow: 0 0 8px #4ade80, 0 0 15px #4ade80;
      animation: ledPulse 2s ease-in-out infinite;
    }

    @keyframes ledPulse {
      0%, 100% { opacity: 1; box-shadow: 0 0 8px #4ade80, 0 0 15px #4ade80; }
      50% { opacity: 0.7; box-shadow: 0 0 4px #4ade80, 0 0 8px #4ade80; }
    }

    /* D-pad hint */
    .dpad-area {
      position: absolute;
      bottom: 0.8rem;
      right: 1.5rem;
      display: flex;
      gap: 0.5rem;
    }

    .btn-hint {
      width: 20px;
      height: 20px;
      background: #3a3a4a;
      border-radius: 50%;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.5), 0 1px 2px rgba(255,255,255,0.1);
    }

    .btn-hint.a { background: #c44569; }
    .btn-hint.b { background: #c44569; }

    .stat-box {
      position: absolute;
      background: rgba(13, 13, 18, 0.95);
      border: 3px solid #3a3a4a;
      padding: 0.5rem 0.7rem;
      min-width: 110px;
      z-index: 10;
    }

    .stat-box.enemy {
      top: 8%;
      left: 5%;
      border-color: var(--void-mid);
      box-shadow: 0 0 15px rgba(123, 44, 191, 0.4);
    }

    .stat-box.player {
      bottom: 22%;
      right: 5%;
      border-color: var(--flame-mid);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.4);
    }

    .stat-name {
      font-size: 0.4rem;
      color: #e8e8e8;
      margin-bottom: 0.3rem;
      letter-spacing: 0.05em;
    }

    .stat-level {
      font-size: 0.3rem;
      color: #888;
      margin-left: 0.3rem;
    }

    .stat-bar-container {
      display: flex;
      align-items: center;
      gap: 0.3rem;
    }

    .stat-label {
      font-size: 0.28rem;
      color: var(--flame-mid);
      font-weight: bold;
    }

    .stat-bar {
      flex: 1;
      height: 6px;
      background: #1a1a24;
      border-radius: 2px;
      overflow: hidden;
      border: 1px solid #3a3a4a;
    }

    .stat-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #4ade80, #22c55e);
      transition: width 0.3s ease;
      box-shadow: 0 0 4px #4ade80;
    }

    .stat-bar-fill.medium {
      background: linear-gradient(90deg, #fbbf24, #f59e0b);
      box-shadow: 0 0 4px #fbbf24;
    }
    .stat-bar-fill.low {
      background: linear-gradient(90deg, #f87171, #ef4444);
      box-shadow: 0 0 4px #f87171;
      animation: lowHpPulse 0.5s ease-in-out infinite;
    }

    @keyframes lowHpPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .stat-hp-text {
      font-size: 0.25rem;
      color: #888;
      text-align: right;
      margin-top: 0.2rem;
    }

    .title {
      position: absolute;
      top: 1rem;
      left: 0;
      right: 0;
      text-align: center;
      font-size: clamp(0.5rem, 1.8vw, 0.75rem);
      color: #e8e8e8;
      letter-spacing: 0.3em;
      text-shadow: 2px 2px 0 #0d0d12, 0 0 20px rgba(199, 125, 255, 0.6);
      z-index: 10;
    }

    /* Battle action box */
    .action-box {
      position: absolute;
      bottom: 5%;
      right: 5%;
      background: rgba(13, 13, 18, 0.95);
      border: 3px solid #3a3a4a;
      padding: 0.4rem;
      z-index: 10;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.25rem;
    }

    .action-btn {
      font-family: 'Press Start 2P', cursive;
      font-size: 0.28rem;
      padding: 0.35rem 0.5rem;
      background: #1a1a2e;
      border: 2px solid #3a3a4a;
      color: #777;
      cursor: pointer;
      transition: all 0.15s;
    }

    .action-btn:hover {
      background: #2a2a3e;
      color: #c77dff;
      border-color: var(--void-mid);
      box-shadow: 0 0 8px rgba(157, 78, 221, 0.4);
    }

    .action-btn:active {
      transform: scale(0.95);
    }

    /* Message box */
    .message-box {
      position: absolute;
      bottom: 5%;
      left: 5%;
      width: 45%;
      background: rgba(13, 13, 18, 0.95);
      border: 3px solid #3a3a4a;
      padding: 0.5rem 0.6rem;
      z-index: 10;
    }

    .message-text {
      font-size: 0.3rem;
      color: #ccc;
      line-height: 1.6;
    }

    .arena-floor {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 30%;
      background: linear-gradient(180deg, transparent 0%, rgba(20, 20, 35, 0.5) 40%, rgba(15, 15, 25, 0.7) 100%);
      z-index: 2;
    }

    #battle-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 5;
    }

    .crt-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 20;
      background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.06) 2px, rgba(0,0,0,0.06) 4px);
    }

    .tap-hint {
      position: absolute;
      bottom: 4rem;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 0.3rem;
      color: #444;
      z-index: 10;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    .footer {
      text-align: center;
      margin-top: 0.8rem;
    }

    .x-link {
      font-size: 0.3rem;
      color: rgba(255,255,255,0.6);
      text-decoration: none;
      transition: all 0.3s;
      letter-spacing: 0.02em;
    }

    .x-link:hover {
      color: #fff;
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
    }

    .link-divider {
      color: rgba(255,255,255,0.3);
      margin: 0 0.4rem;
      font-size: 0.3rem;
    }

    .damage-text {
      position: absolute;
      font-size: 0.5rem;
      color: #fff;
      text-shadow: 2px 2px 0 #000;
      pointer-events: none;
      z-index: 15;
      animation: damageFloat 0.8s ease-out forwards;
    }

    @keyframes damageFloat {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0; transform: translateY(-30px) scale(1.2); }
    }

    @media (max-width: 500px) {
      .gameboy-shell {
        padding: 1rem 0.6rem 2rem 0.6rem;
        border-radius: 15px 15px 40px 40px;
      }
      .gameboy-label { font-size: 0.28rem; }
      .screen-bezel { padding: 0.4rem; }
      .stat-box { min-width: 70px; padding: 0.3rem 0.4rem; }
      .stat-name { font-size: 0.3rem; }
      .stat-level { font-size: 0.22rem; }
      .title { font-size: 0.4rem; }
      .message-box { width: 40%; padding: 0.3rem 0.4rem; }
      .message-text { font-size: 0.22rem; }
      .action-box { padding: 0.3rem; }
      .action-btn { font-size: 0.22rem; padding: 0.25rem 0.35rem; }
      .footer { margin-top: 0.5rem; }
      .x-link, .link-divider { font-size: 0.25rem; }
      .power-led { width: 6px; height: 6px; bottom: 0.8rem; left: 1rem; }
      .dpad-area { bottom: 0.5rem; right: 1rem; }
      .btn-hint { width: 15px; height: 15px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="gameboy-shell">
      <div class="gameboy-label">GAME BOY <span>COLOR</span></div>
      <div class="screen-bezel">
        <div class="viewport" id="viewport">
          <h1 class="title">BAGUETTE</h1>

      <!-- Enemy stat box - top left -->
      <div class="stat-box enemy">
        <div class="stat-name">VOID SPECTER<span class="stat-level">Lv50</span></div>
        <div class="stat-bar-container">
          <span class="stat-label">HP</span>
          <div class="stat-bar">
            <div class="stat-bar-fill" id="enemy-hp" style="width: 100%"></div>
          </div>
        </div>
      </div>

      <!-- Player stat box - bottom right -->
      <div class="stat-box player">
        <div class="stat-name">BAGUETTE<span class="stat-level">Lv50</span></div>
        <div class="stat-bar-container">
          <span class="stat-label">HP</span>
          <div class="stat-bar">
            <div class="stat-bar-fill" id="player-hp" style="width: 100%"></div>
          </div>
        </div>
        <div class="stat-hp-text"><span id="player-hp-num">100</span> / 100</div>
      </div>

      <canvas id="battle-canvas"></canvas>

      <div class="arena-floor"></div>
      <div class="crt-overlay"></div>

      <!-- Message box -->
      <div class="message-box">
        <div class="message-text" id="battle-message">What will BAGUETTE do?</div>
      </div>

      <!-- Action box -->
      <div class="action-box">
        <div class="action-btn" data-action="fight">FIGHT</div>
        <div class="action-btn" data-action="magic">MAGIC</div>
        <div class="action-btn" data-action="item">ITEM</div>
        <div class="action-btn" data-action="run">RUN</div>
      </div>

        </div>
      </div>
      <div class="power-led"></div>
      <div class="dpad-area">
        <div class="btn-hint b"></div>
        <div class="btn-hint a"></div>
      </div>
      <div class="footer">
        <a href="mailto:hello@baguette.art" class="x-link">hello@baguette.art</a>
        <span class="link-divider">/</span>
        <a href="https://x.com/baguetteanon" target="_blank" rel="noopener" class="x-link">@baguetteanon</a>
      </div>
    </div>
  </div>

  <script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>
  <script type="module">
    import * as THREE from 'three';

    const canvas = document.getElementById('battle-canvas');
    const viewport = document.getElementById('viewport');
    const enemyHpBar = document.getElementById('enemy-hp');
    const playerHpBar = document.getElementById('player-hp');

    let enemyHp = 100;
    let playerHp = 100;

    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
    camera.position.z = 5;

    // Orb shader
    const orbVertexShader = `
      varying vec3 vNormal;
      varying vec3 vPosition;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        vPosition = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const createOrbFragmentShader = (baseColor, accentColor) => `
      uniform float uTime;
      uniform float uHit;
      varying vec3 vNormal;
      varying vec3 vPosition;

      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

      float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;
        i = mod289(i);
        vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
        float n_ = 0.142857142857;
        vec3 ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);
        vec4 x = x_ * ns.x + ns.yyyy;
        vec4 y = y_ * ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);
        vec4 s0 = floor(b0) * 2.0 + 1.0;
        vec4 s1 = floor(b1) * 2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
      }

      void main() {
        float noise = snoise(vPosition * 2.5 + uTime * 0.4);
        float t = noise * 0.5 + 0.5;

        vec3 baseCol = ${baseColor};
        vec3 accentCol = ${accentColor};
        vec3 color = mix(baseCol, accentCol, t);

        vec3 viewDir = normalize(cameraPosition - vPosition);
        float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.5);
        color += fresnel * accentCol * 0.6;

        // Hit flash (white) or heal flash (green)
        if (uHit > 0.0) {
          color = mix(color, vec3(1.0), uHit * 0.8);
        } else if (uHit < 0.0) {
          color = mix(color, vec3(0.3, 1.0, 0.5), -uHit * 0.8);
        }

        gl_FragColor = vec4(color, 1.0);
      }
    `;

    // Player orb (flame)
    const playerMaterial = new THREE.ShaderMaterial({
      vertexShader: orbVertexShader,
      fragmentShader: createOrbFragmentShader('vec3(1.0, 0.35, 0.15)', 'vec3(1.0, 0.85, 0.3)'),
      uniforms: { uTime: { value: 0 }, uHit: { value: 0 } }
    });

    // Enemy orb (void)
    const enemyMaterial = new THREE.ShaderMaterial({
      vertexShader: orbVertexShader,
      fragmentShader: createOrbFragmentShader('vec3(0.45, 0.15, 0.75)', 'vec3(0.8, 0.5, 1.0)'),
      uniforms: { uTime: { value: 0 }, uHit: { value: 0 } }
    });

    const orbGeometry = new THREE.SphereGeometry(0.6, 48, 48);

    // Glow shader for outer aura
    const glowVertexShader = `
      varying vec3 vNormal;
      varying vec3 vPositionNormal;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        vPositionNormal = normalize((modelViewMatrix * vec4(position, 1.0)).xyz);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const createGlowFragmentShader = (color1, color2) => `
      uniform float uTime;
      uniform float uIntensity;
      varying vec3 vNormal;
      varying vec3 vPositionNormal;
      void main() {
        float intensity = pow(0.7 - dot(vNormal, vPositionNormal), 2.0);
        intensity *= uIntensity;
        float pulse = 0.8 + 0.2 * sin(uTime * 3.0);
        vec3 color1 = ${color1};
        vec3 color2 = ${color2};
        vec3 glow = mix(color1, color2, intensity) * pulse;
        gl_FragColor = vec4(glow, intensity * 0.8);
      }
    `;

    // Player glow
    const playerGlowMaterial = new THREE.ShaderMaterial({
      vertexShader: glowVertexShader,
      fragmentShader: createGlowFragmentShader('vec3(1.0, 0.4, 0.1)', 'vec3(1.0, 0.9, 0.3)'),
      uniforms: { uTime: { value: 0 }, uIntensity: { value: 1.5 } },
      transparent: true,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide,
      depthWrite: false
    });

    // Enemy glow
    const enemyGlowMaterial = new THREE.ShaderMaterial({
      vertexShader: glowVertexShader,
      fragmentShader: createGlowFragmentShader('vec3(0.5, 0.1, 0.8)', 'vec3(0.8, 0.4, 1.0)'),
      uniforms: { uTime: { value: 0 }, uIntensity: { value: 1.5 } },
      transparent: true,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide,
      depthWrite: false
    });

    const glowGeometry = new THREE.SphereGeometry(0.85, 32, 32);

    // Player orb + glow
    const playerOrb = new THREE.Mesh(orbGeometry, playerMaterial);
    playerOrb.position.set(-1.5, -0.5, 0);
    playerOrb.userData = { type: 'player', baseY: -0.5 };
    scene.add(playerOrb);

    const playerGlow = new THREE.Mesh(glowGeometry, playerGlowMaterial);
    playerGlow.position.copy(playerOrb.position);
    scene.add(playerGlow);

    // Enemy orb + glow
    const enemyOrb = new THREE.Mesh(orbGeometry, enemyMaterial);
    enemyOrb.position.set(1.5, 0.5, 0);
    enemyOrb.userData = { type: 'enemy', baseY: 0.5 };
    scene.add(enemyOrb);

    const enemyGlow = new THREE.Mesh(glowGeometry, enemyGlowMaterial);
    enemyGlow.position.copy(enemyOrb.position);
    scene.add(enemyGlow);

    // Attack particles
    const attackParticles = [];

    function createAttackParticle(from, to, color) {
      const geometry = new THREE.SphereGeometry(0.08, 16, 16);
      const material = new THREE.MeshBasicMaterial({
        color: new THREE.Color(color),
        transparent: true,
        opacity: 1
      });
      const particle = new THREE.Mesh(geometry, material);
      particle.position.copy(from);
      particle.userData = {
        start: from.clone(),
        end: to.clone(),
        progress: 0,
        speed: 3
      };
      scene.add(particle);
      attackParticles.push(particle);
      return particle;
    }

    // Burst particles on hit
    const burstParticles = [];

    function createBurstParticles(position, color, count = 12) {
      for (let i = 0; i < count; i++) {
        const geometry = new THREE.SphereGeometry(0.05, 8, 8);
        const material = new THREE.MeshBasicMaterial({
          color: new THREE.Color(color),
          transparent: true,
          opacity: 1
        });
        const particle = new THREE.Mesh(geometry, material);
        particle.position.copy(position);

        const angle = (i / count) * Math.PI * 2;
        const speed = 0.5 + Math.random() * 0.5;
        particle.userData = {
          velocity: new THREE.Vector3(
            Math.cos(angle) * speed,
            Math.sin(angle) * speed + 0.3,
            (Math.random() - 0.5) * speed
          ),
          life: 1
        };
        scene.add(particle);
        burstParticles.push(particle);
      }
    }

    // Raycaster for tap detection
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function onTap(event) {
      const rect = canvas.getBoundingClientRect();
      const x = (event.touches ? event.touches[0].clientX : event.clientX) - rect.left;
      const y = (event.touches ? event.touches[0].clientY : event.clientY) - rect.top;

      pointer.x = (x / rect.width) * 2 - 1;
      pointer.y = -(y / rect.height) * 2 + 1;

      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects([playerOrb, enemyOrb]);

      if (intersects.length > 0) {
        const hit = intersects[0].object;

        if (hit.userData.type === 'player') {
          // Player attacks enemy
          createAttackParticle(
            playerOrb.position.clone(),
            enemyOrb.position.clone(),
            '#ff6b35'
          );
        } else {
          // Enemy attacks player
          createAttackParticle(
            enemyOrb.position.clone(),
            playerOrb.position.clone(),
            '#9d4edd'
          );
        }
      }
    }

    canvas.addEventListener('click', onTap);
    canvas.addEventListener('touchstart', onTap, { passive: true });

    function showDamage(position, amount, isEnemy) {
      const div = document.createElement('div');
      div.className = 'damage-text';
      div.textContent = `-${amount}`;
      div.style.color = isEnemy ? '#c77dff' : '#ff6b35';

      // Project 3D position to screen
      const vector = position.clone();
      vector.project(camera);

      const rect = viewport.getBoundingClientRect();
      const x = ((vector.x + 1) / 2) * rect.width;
      const y = ((-vector.y + 1) / 2) * rect.height;

      div.style.left = x + 'px';
      div.style.top = y + 'px';

      viewport.appendChild(div);
      setTimeout(() => div.remove(), 800);
    }

    const playerHpNum = document.getElementById('player-hp-num');
    const battleMessage = document.getElementById('battle-message');

    function updateHpBar(bar, hp) {
      bar.style.width = hp + '%';
      bar.classList.remove('medium', 'low');
      if (hp <= 25) bar.classList.add('low');
      else if (hp <= 50) bar.classList.add('medium');

      // Update numeric display for player
      if (bar === playerHpBar) {
        playerHpNum.textContent = Math.round(hp);
      }
    }

    function showBattleMessage(msg) {
      battleMessage.textContent = msg;
    }

    function useMaxPotion() {
      // Show message sequence
      showBattleMessage('BAGUETTE used MAX POTION!');

      // Create healing particles
      createHealParticles(playerOrb.position);

      // Delay the heal effect
      setTimeout(() => {
        playerHp = 100;
        updateHpBar(playerHpBar, 100);
        showBattleMessage('BAGUETTE\'s HP was fully restored!');

        // Flash the orb green
        playerMaterial.uniforms.uHit.value = -1; // negative for green flash

        setTimeout(() => {
          showBattleMessage('What will BAGUETTE do?');
        }, 1500);
      }, 800);
    }

    function createHealParticles(position) {
      for (let i = 0; i < 20; i++) {
        const geometry = new THREE.SphereGeometry(0.04, 8, 8);
        const material = new THREE.MeshBasicMaterial({
          color: new THREE.Color('#4ade80'),
          transparent: true,
          opacity: 1
        });
        const particle = new THREE.Mesh(geometry, material);

        // Start from below and rise up
        particle.position.set(
          position.x + (Math.random() - 0.5) * 0.8,
          position.y - 0.5,
          position.z + (Math.random() - 0.5) * 0.8
        );

        particle.userData = {
          velocity: new THREE.Vector3(
            (Math.random() - 0.5) * 0.3,
            1.5 + Math.random() * 0.5,
            (Math.random() - 0.5) * 0.3
          ),
          life: 1,
          isHeal: true
        };
        scene.add(particle);
        burstParticles.push(particle);
      }
    }

    function resize() {
      const rect = canvas.getBoundingClientRect();
      renderer.setSize(rect.width, rect.height);
      camera.aspect = rect.width / rect.height;
      camera.updateProjectionMatrix();
    }

    resize();
    window.addEventListener('resize', resize);

    let lastTime = 0;
    function animate(time) {
      const delta = (time - lastTime) / 1000;
      lastTime = time;
      const t = time * 0.001;

      // Update orb shaders
      playerMaterial.uniforms.uTime.value = t;
      enemyMaterial.uniforms.uTime.value = t;

      // Decay hit flash
      playerMaterial.uniforms.uHit.value *= 0.9;
      enemyMaterial.uniforms.uHit.value *= 0.9;

      // Update glow shaders
      playerGlowMaterial.uniforms.uTime.value = t;
      enemyGlowMaterial.uniforms.uTime.value = t;

      // Idle animation
      playerOrb.position.y = playerOrb.userData.baseY + Math.sin(t * 2) * 0.1;
      enemyOrb.position.y = enemyOrb.userData.baseY + Math.sin(t * 2 + 1) * 0.1;

      // Sync glow positions
      playerGlow.position.copy(playerOrb.position);
      enemyGlow.position.copy(enemyOrb.position);

      // Update attack particles
      for (let i = attackParticles.length - 1; i >= 0; i--) {
        const p = attackParticles[i];
        p.userData.progress += delta * p.userData.speed;

        if (p.userData.progress >= 1) {
          // Hit!
          const target = p.userData.end;
          const isEnemy = target.x > 0;

          if (isEnemy) {
            enemyMaterial.uniforms.uHit.value = 1;
            const damage = 8 + Math.floor(Math.random() * 7);
            enemyHp = Math.max(0, enemyHp - damage);
            updateHpBar(enemyHpBar, enemyHp);
            showDamage(enemyOrb.position, damage, true);
            createBurstParticles(enemyOrb.position, '#c77dff');
          } else {
            playerMaterial.uniforms.uHit.value = 1;
            const damage = 8 + Math.floor(Math.random() * 7);
            playerHp = Math.max(0, playerHp - damage);
            updateHpBar(playerHpBar, playerHp);
            showDamage(playerOrb.position, damage, false);
            createBurstParticles(playerOrb.position, '#ff6b35');

            // Max Potion when about to die!
            if (playerHp <= 15 && playerHp > 0) {
              useMaxPotion();
            }
          }

          scene.remove(p);
          attackParticles.splice(i, 1);

          // Reset enemy when defeated
          if (enemyHp <= 0) {
            showBattleMessage('VOID SPECTER fainted!');
            setTimeout(() => {
              enemyHp = 100;
              updateHpBar(enemyHpBar, 100);
              showBattleMessage('A new VOID SPECTER appeared!');
            }, 2000);
          }
        } else {
          p.position.lerpVectors(p.userData.start, p.userData.end, p.userData.progress);
          p.scale.setScalar(1 + Math.sin(p.userData.progress * Math.PI) * 0.5);
        }
      }

      // Update burst particles
      for (let i = burstParticles.length - 1; i >= 0; i--) {
        const p = burstParticles[i];
        p.position.add(p.userData.velocity.clone().multiplyScalar(delta));

        // Heal particles rise, damage particles fall
        if (p.userData.isHeal) {
          p.userData.velocity.y *= 0.98; // slow down rise
          p.userData.life -= delta * 1.5;
        } else {
          p.userData.velocity.y -= delta * 2;
          p.userData.life -= delta * 2;
        }

        p.material.opacity = p.userData.life;

        if (p.userData.life <= 0) {
          scene.remove(p);
          burstParticles.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate(0);
  </script>
</body>
</html>
