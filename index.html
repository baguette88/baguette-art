<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Baguette</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-dark: #0d0d12;
      --void-core: #7b2cbf;
      --void-mid: #9d4edd;
      --void-outer: #c77dff;
      --flame-core: #ff6b35;
      --flame-mid: #f7931e;
      --flame-outer: #ffd23f;
    }

    html, body {
      height: 100%;
      width: 100%;
      background: var(--bg-dark);
      font-family: 'Press Start 2P', cursive;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
    }

    .container {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }

    .viewport {
      width: min(95vw, 95vh, 600px);
      height: min(95vw, 95vh, 600px);
      background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 50%, #1a1a2e 100%);
      border: 4px solid #2a2a3a;
      border-radius: 4px;
      position: relative;
      overflow: hidden;
      box-shadow:
        0 0 0 4px #0d0d12,
        0 0 60px rgba(123, 44, 191, 0.3),
        0 0 100px rgba(255, 107, 53, 0.2);
    }

    .battle-header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 0.8rem;
      display: flex;
      justify-content: space-between;
      z-index: 10;
    }

    .stat-box {
      background: rgba(13, 13, 18, 0.9);
      border: 2px solid #3a3a4a;
      padding: 0.4rem 0.6rem;
      min-width: 90px;
    }

    .stat-box.enemy { border-color: var(--void-mid); }
    .stat-box.player { border-color: var(--flame-mid); }

    .stat-name {
      font-size: 0.35rem;
      color: #e8e8e8;
      margin-bottom: 0.25rem;
    }

    .stat-bar-container {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .stat-label {
      font-size: 0.25rem;
      color: var(--flame-mid);
    }

    .stat-bar {
      flex: 1;
      height: 4px;
      background: #2a2a3a;
      border-radius: 1px;
      overflow: hidden;
    }

    .stat-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #4ade80, #22c55e);
      transition: width 0.3s ease;
    }

    .stat-bar-fill.medium { background: linear-gradient(90deg, #fbbf24, #f59e0b); }
    .stat-bar-fill.low { background: linear-gradient(90deg, #f87171, #ef4444); }

    .title {
      position: absolute;
      top: 3.5rem;
      left: 0;
      right: 0;
      text-align: center;
      font-size: clamp(0.45rem, 1.5vw, 0.65rem);
      color: #e8e8e8;
      letter-spacing: 0.25em;
      text-shadow: 2px 2px 0 #0d0d12, 0 0 15px rgba(199, 125, 255, 0.5);
      z-index: 10;
    }

    .arena-floor {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 30%;
      background: linear-gradient(180deg, transparent 0%, rgba(20, 20, 35, 0.5) 40%, rgba(15, 15, 25, 0.7) 100%);
      z-index: 2;
    }

    #battle-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 5;
    }

    .crt-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 20;
      background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.06) 2px, rgba(0,0,0,0.06) 4px);
    }

    .tap-hint {
      position: absolute;
      bottom: 4rem;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 0.3rem;
      color: #444;
      z-index: 10;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    .footer {
      position: absolute;
      bottom: 0.8rem;
      left: 0;
      right: 0;
      text-align: center;
      z-index: 10;
    }

    .x-link {
      font-size: 0.3rem;
      color: #444;
      text-decoration: none;
      margin: 0 0.3rem;
      transition: color 0.3s;
    }

    .x-link:hover { color: #c77dff; }

    .damage-text {
      position: absolute;
      font-size: 0.5rem;
      color: #fff;
      text-shadow: 2px 2px 0 #000;
      pointer-events: none;
      z-index: 15;
      animation: damageFloat 0.8s ease-out forwards;
    }

    @keyframes damageFloat {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0; transform: translateY(-30px) scale(1.2); }
    }

    @media (max-width: 400px) {
      .stat-box { min-width: 70px; padding: 0.3rem 0.4rem; }
      .stat-name { font-size: 0.28rem; }
      .title { font-size: 0.4rem; top: 3rem; }
      .tap-hint { font-size: 0.25rem; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="viewport" id="viewport">
      <div class="battle-header">
        <div class="stat-box enemy">
          <div class="stat-name">SPECTER</div>
          <div class="stat-bar-container">
            <span class="stat-label">HP</span>
            <div class="stat-bar">
              <div class="stat-bar-fill" id="enemy-hp" style="width: 100%"></div>
            </div>
          </div>
        </div>
        <div class="stat-box player">
          <div class="stat-name">BAGUETTE</div>
          <div class="stat-bar-container">
            <span class="stat-label">HP</span>
            <div class="stat-bar">
              <div class="stat-bar-fill" id="player-hp" style="width: 100%"></div>
            </div>
          </div>
        </div>
      </div>

      <h1 class="title">BAGUETTE</h1>

      <canvas id="battle-canvas"></canvas>

      <div class="arena-floor"></div>
      <div class="crt-overlay"></div>

      <div class="tap-hint">TAP CREATURE TO ATTACK</div>

      <div class="footer">
        <a href="mailto:hello@baguette.art" class="x-link">hello@baguette.art</a>
        <a href="https://x.com/baguetteanon" target="_blank" rel="noopener" class="x-link">@baguetteanon</a>
      </div>
    </div>
  </div>

  <script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>
  <script type="module">
    import * as THREE from 'three';

    const canvas = document.getElementById('battle-canvas');
    const viewport = document.getElementById('viewport');
    const enemyHpBar = document.getElementById('enemy-hp');
    const playerHpBar = document.getElementById('player-hp');

    let enemyHp = 100;
    let playerHp = 100;

    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
    camera.position.z = 5;

    // Orb shader
    const orbVertexShader = `
      varying vec3 vNormal;
      varying vec3 vPosition;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        vPosition = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const createOrbFragmentShader = (baseColor, accentColor) => `
      uniform float uTime;
      uniform float uHit;
      varying vec3 vNormal;
      varying vec3 vPosition;

      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

      float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;
        i = mod289(i);
        vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
        float n_ = 0.142857142857;
        vec3 ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);
        vec4 x = x_ * ns.x + ns.yyyy;
        vec4 y = y_ * ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);
        vec4 s0 = floor(b0) * 2.0 + 1.0;
        vec4 s1 = floor(b1) * 2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
      }

      void main() {
        float noise = snoise(vPosition * 2.5 + uTime * 0.4);
        float t = noise * 0.5 + 0.5;

        vec3 baseCol = ${baseColor};
        vec3 accentCol = ${accentColor};
        vec3 color = mix(baseCol, accentCol, t);

        vec3 viewDir = normalize(cameraPosition - vPosition);
        float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 2.5);
        color += fresnel * accentCol * 0.6;

        // Hit flash
        color = mix(color, vec3(1.0), uHit * 0.8);

        gl_FragColor = vec4(color, 1.0);
      }
    `;

    // Player orb (flame)
    const playerMaterial = new THREE.ShaderMaterial({
      vertexShader: orbVertexShader,
      fragmentShader: createOrbFragmentShader('vec3(1.0, 0.35, 0.15)', 'vec3(1.0, 0.85, 0.3)'),
      uniforms: { uTime: { value: 0 }, uHit: { value: 0 } }
    });

    // Enemy orb (void)
    const enemyMaterial = new THREE.ShaderMaterial({
      vertexShader: orbVertexShader,
      fragmentShader: createOrbFragmentShader('vec3(0.45, 0.15, 0.75)', 'vec3(0.8, 0.5, 1.0)'),
      uniforms: { uTime: { value: 0 }, uHit: { value: 0 } }
    });

    const orbGeometry = new THREE.SphereGeometry(0.6, 48, 48);

    const playerOrb = new THREE.Mesh(orbGeometry, playerMaterial);
    playerOrb.position.set(-1.5, -0.5, 0);
    playerOrb.userData = { type: 'player', baseY: -0.5 };
    scene.add(playerOrb);

    const enemyOrb = new THREE.Mesh(orbGeometry, enemyMaterial);
    enemyOrb.position.set(1.5, 0.5, 0);
    enemyOrb.userData = { type: 'enemy', baseY: 0.5 };
    scene.add(enemyOrb);

    // Attack particles
    const attackParticles = [];

    function createAttackParticle(from, to, color) {
      const geometry = new THREE.SphereGeometry(0.08, 16, 16);
      const material = new THREE.MeshBasicMaterial({
        color: new THREE.Color(color),
        transparent: true,
        opacity: 1
      });
      const particle = new THREE.Mesh(geometry, material);
      particle.position.copy(from);
      particle.userData = {
        start: from.clone(),
        end: to.clone(),
        progress: 0,
        speed: 3
      };
      scene.add(particle);
      attackParticles.push(particle);
      return particle;
    }

    // Burst particles on hit
    const burstParticles = [];

    function createBurstParticles(position, color, count = 12) {
      for (let i = 0; i < count; i++) {
        const geometry = new THREE.SphereGeometry(0.05, 8, 8);
        const material = new THREE.MeshBasicMaterial({
          color: new THREE.Color(color),
          transparent: true,
          opacity: 1
        });
        const particle = new THREE.Mesh(geometry, material);
        particle.position.copy(position);

        const angle = (i / count) * Math.PI * 2;
        const speed = 0.5 + Math.random() * 0.5;
        particle.userData = {
          velocity: new THREE.Vector3(
            Math.cos(angle) * speed,
            Math.sin(angle) * speed + 0.3,
            (Math.random() - 0.5) * speed
          ),
          life: 1
        };
        scene.add(particle);
        burstParticles.push(particle);
      }
    }

    // Raycaster for tap detection
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function onTap(event) {
      const rect = canvas.getBoundingClientRect();
      const x = (event.touches ? event.touches[0].clientX : event.clientX) - rect.left;
      const y = (event.touches ? event.touches[0].clientY : event.clientY) - rect.top;

      pointer.x = (x / rect.width) * 2 - 1;
      pointer.y = -(y / rect.height) * 2 + 1;

      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects([playerOrb, enemyOrb]);

      if (intersects.length > 0) {
        const hit = intersects[0].object;

        if (hit.userData.type === 'player') {
          // Player attacks enemy
          createAttackParticle(
            playerOrb.position.clone(),
            enemyOrb.position.clone(),
            '#ff6b35'
          );
        } else {
          // Enemy attacks player
          createAttackParticle(
            enemyOrb.position.clone(),
            playerOrb.position.clone(),
            '#9d4edd'
          );
        }
      }
    }

    canvas.addEventListener('click', onTap);
    canvas.addEventListener('touchstart', onTap, { passive: true });

    function showDamage(position, amount, isEnemy) {
      const div = document.createElement('div');
      div.className = 'damage-text';
      div.textContent = `-${amount}`;
      div.style.color = isEnemy ? '#c77dff' : '#ff6b35';

      // Project 3D position to screen
      const vector = position.clone();
      vector.project(camera);

      const rect = viewport.getBoundingClientRect();
      const x = ((vector.x + 1) / 2) * rect.width;
      const y = ((-vector.y + 1) / 2) * rect.height;

      div.style.left = x + 'px';
      div.style.top = y + 'px';

      viewport.appendChild(div);
      setTimeout(() => div.remove(), 800);
    }

    function updateHpBar(bar, hp) {
      bar.style.width = hp + '%';
      bar.classList.remove('medium', 'low');
      if (hp <= 25) bar.classList.add('low');
      else if (hp <= 50) bar.classList.add('medium');
    }

    function resize() {
      const rect = canvas.getBoundingClientRect();
      renderer.setSize(rect.width, rect.height);
      camera.aspect = rect.width / rect.height;
      camera.updateProjectionMatrix();
    }

    resize();
    window.addEventListener('resize', resize);

    let lastTime = 0;
    function animate(time) {
      const delta = (time - lastTime) / 1000;
      lastTime = time;
      const t = time * 0.001;

      // Update orb shaders
      playerMaterial.uniforms.uTime.value = t;
      enemyMaterial.uniforms.uTime.value = t;

      // Decay hit flash
      playerMaterial.uniforms.uHit.value *= 0.9;
      enemyMaterial.uniforms.uHit.value *= 0.9;

      // Idle animation
      playerOrb.position.y = playerOrb.userData.baseY + Math.sin(t * 2) * 0.1;
      enemyOrb.position.y = enemyOrb.userData.baseY + Math.sin(t * 2 + 1) * 0.1;

      // Update attack particles
      for (let i = attackParticles.length - 1; i >= 0; i--) {
        const p = attackParticles[i];
        p.userData.progress += delta * p.userData.speed;

        if (p.userData.progress >= 1) {
          // Hit!
          const target = p.userData.end;
          const isEnemy = target.x > 0;

          if (isEnemy) {
            enemyMaterial.uniforms.uHit.value = 1;
            const damage = 8 + Math.floor(Math.random() * 7);
            enemyHp = Math.max(0, enemyHp - damage);
            updateHpBar(enemyHpBar, enemyHp);
            showDamage(enemyOrb.position, damage, true);
            createBurstParticles(enemyOrb.position, '#c77dff');
          } else {
            playerMaterial.uniforms.uHit.value = 1;
            const damage = 8 + Math.floor(Math.random() * 7);
            playerHp = Math.max(0, playerHp - damage);
            updateHpBar(playerHpBar, playerHp);
            showDamage(playerOrb.position, damage, false);
            createBurstParticles(playerOrb.position, '#ff6b35');
          }

          scene.remove(p);
          attackParticles.splice(i, 1);

          // Reset HP when one dies
          if (enemyHp <= 0 || playerHp <= 0) {
            setTimeout(() => {
              enemyHp = 100;
              playerHp = 100;
              updateHpBar(enemyHpBar, 100);
              updateHpBar(playerHpBar, 100);
            }, 1000);
          }
        } else {
          p.position.lerpVectors(p.userData.start, p.userData.end, p.userData.progress);
          p.scale.setScalar(1 + Math.sin(p.userData.progress * Math.PI) * 0.5);
        }
      }

      // Update burst particles
      for (let i = burstParticles.length - 1; i >= 0; i--) {
        const p = burstParticles[i];
        p.position.add(p.userData.velocity.clone().multiplyScalar(delta));
        p.userData.velocity.y -= delta * 2;
        p.userData.life -= delta * 2;
        p.material.opacity = p.userData.life;

        if (p.userData.life <= 0) {
          scene.remove(p);
          burstParticles.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate(0);
  </script>
</body>
</html>
